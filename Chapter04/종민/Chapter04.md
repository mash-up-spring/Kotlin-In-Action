# 클래스, 객체, 인터페이스
## 클래스 계층 정의
### 4.1.1 코틀린 인터페이스
```
class Button : Clickable {
    override fun click() = println("I was clicked")
}
```
- 코틀린에서는 클래스 이름 뒤에 콜론을 붙이고 인터페이스와 클래스 명을 적는 것으로 클래스 확장, 인터페이스 구현을 모두 처리
- 자바에서는 override 애노테이션 안써도되는데 쓰면 잡아주는 역할을 하는데, 코틀린은 반드시 써야 해줘야 한다.
- default 구현은 특별한 키워드 없이 메소드 본문을 메소드 시그니처 뒤에 추가하면 됨

### 4.1.2 open, final, abstract 변경자: 기본적으로 final
- 자바에서는 final로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있다.
- 취약한 기반 클래스: 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경하면서 깨지는 경우
- 기반클래스에서 뭔가 조금 바뀌면, 그 아래의 모든 하위 클래스에 영향을 준다
- 반드시 확실하게 IS A 관계일때만 상속을 하고, 그 계층 또한 깊어지면 안됨...!
- 코틀린에서는 기본적으로 final이므로 상속을 허용하려면 open 변경자를 붙여야 한다.
- 더불어 메소드에서도 오버라이드를 허용하려면 open을 메소드 앞에 해줘야 한다.
- final일 때는 스마트 캐스트 사용 가능

### 4.1.3 가시성 변경자: 기본적으로 공개
- 아무 변경자도 없는 경우 선언은 모두 public
- internal : 모듈 내부에서만 볼 수 있음
- 코틀린은 중첩 클래스가 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다.

### 4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스
- 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다
- 자바에서는 inner class가 바깥쪽 클래스에 대한 참조를 묵시적으로 포함 -> 없이려면 inner class를 static 클래스로 선언

두 개의 가장 큰 차이점은 자신을 감싸고 있는 외곽 클래스 객체와의 연결 여부이다. 중첩 클래스는 외곽 클래스 객체의 참조가 없어도 객체를 생성할 수 있는 반면 내부 클래스는 외곽 클래스 객체를 통해서만 객체를 생성할 수 있다. 
https://medium.com/depayse/kotlin-%ED%81%B4%EB%9E%98%EC%8A%A4-7-%EC%A4%91%EC%B2%A9-%ED%81%B4%EB%9E%98%EC%8A%A4-nested-class-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4-inner-class-266be17619b5

- 코틀린에서 바깥쪽의 참조에 접근하려면 this@Outer
- 클래스 계층을 만들되 그 계층에 속한 클래스의 수를 제한하고 싶은 경우 중첩 클래스를 사용

### 4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한
- 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다
- sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩

## 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
- 주 생성자: 클래스를 초기화할 때 주로 사용하는 간략한 생성자로, 클래스 본문 밖에 정의
- 부 생성자: 클래스 본문 안에서 정의

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록
``` class User(val nickname: String) ```
- 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다.

### 4.2.2 부 생성자: 상위 클래스를 다른 방식으로 초기화
- 클래스에 주 생성자가 앖다면 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 함

### 4.2.3 인터페이스에 선언된 프로퍼티 구현
- 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다

```
interface User{
    val nickname: String
}
```
- User 인터페이스를 구현하는 클래스가 nickname을 얻을 수 있는 방법을 제공해야 한다.

### 4.2.4 게터와 세터에서 뒷받침하는 필드에 접근
- 접근자의 본문에서는 field라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다
- 코틀린 클래스에서는 필드를 직접적으로 선언할 수 없습니다. 따라서 값을 저장하는 동시에 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드(backing field)가 있어야 합니다. 접근자의 본문에서는 field 식별자를 이용하여 backing field에 접근할 수 있습니다. getter에서는 field값을 읽을수만 있고 setter에서는 field 값을 읽거나 쓸 수 있습니다.
- 코틀린에서는 getter, setter, field합쳐서 property라고 하는거같은데 맞나?

### 4.2.5 접근자의 가시성 변경
- private set
- lateinit 변경자를 널이 될 수 없는 프로퍼티에 지정하면 프로퍼티를 생성자가 호출된 다음 초기화 한다.

## 4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임
### 4.3.1 모든 클래스가 정의해야 하는 메소드
- toString, equals, hashCode
- 코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사. ===가 동일성

### 4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성
- data 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어줌
- copy 메소드:
```
fun copy(name: String = this.name, postalCode: Int = this.postalCode) = Client(name, postalCode)

val lee = Client("가나다", 111)
val lee2 = lee.copy(postalCode=4000)
```

### 4.3.3 클래스 위임: by 키워드 사용
```
class DelegatingCollection<T>(
    innerList: Collection<T> = ArrayList<T>()
): Collection<T> by innerList{}
```
- 기존 클래스의 메소드에 위임하는 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다.

## 4.4 object 키워드: 클래스 선언과 인스턴스 생성
- 객체 선언은 싱글톤을 정의하는 방법
- companion object는 인스턴스 메소드는 아니지만 어떤 클래스와 관련있는 메소드와 팩토리 메소드를 담을 때 쓰임
? 그냥 static이라고 생각하면 되는건가? -> 아니다 companion object는 객체

### 4.4.1 객체 선언: 싱글톤을 쉽게 만들기
- 객체 선언은 object 키워드로 시작한다
- 프로퍼티 메소드 초기화 블록이 들어가는데 생성자는 쓸 수 없다 -> 생성자 없이 즉시 만들어짐
- 클래스나 인터페이스를 상속할 수 있음

### 4.4.2 companion oobject: 팩토리 메소드와 정적 멤버가 들어갈 장소
- 코틀린 언어는 static을 지원하지 않는다. 대신 최상위 함수와 객체선언을 활용

### 4.4.3 companion oobject을 일반 객체처럼 사용
- Factory처럼 사용 가능
