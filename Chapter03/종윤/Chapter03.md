# 3. 함수 정의와 호출

> 😷 이 글은 "Kotlin In Action"을 공부하며 정리한 내용이며, 문제시 삭제 될 수 있음을 알립니다.

<br>

## 3.1 코틀린에서 컬렉션 만들기

```kotlin
val set = hashSetOf(1, 7, 53)
val list = arrayListOf(1, 7, 53)
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

- 코틀린에서는 다음과 같이 쉽게 컬렉션을 만들 수 있음 즉, 자신만의 컬렉션 기능을 제공하지 않음
- 왜? 자바와 코틀린 사이에서 서로 호출 시에 변환할 필요가 없기때문
- 하지만 코틀린에서는 자바보다 더 많은 기능을 쓸 수 있음(List의 last, max)

<br>

## 3.2 함수를 호출하기 쉽게 만들기

* 코틀린에서는 여러가지 요구 사항을 처리할 수 있는 함수가 표준 라이브러리에 이미 들어가 있음
* 함수 구현 예제(`joinToString()`) 생략

### 3.2.1 이름 붙인 인자

* 함수를 호출 시에 함수의 전달하는 인자 중에 일부의 이름을 명시 가능

  ```kotlin
  joinToString(collection, separator = " ", prefix = "", postfix = ".")
  ```

* 만약 인자 중 어느 하나라도 이름을 명시하고 난 뒤 인자들은 혼동을 막기위해 이름을 꼭 명시

### 3.2.2 디폴트 파라미터 값

* 자바에서는 일부 클래스에서 오버로딩으로 많은 메소드가 생길 수 있다는 문제가 있음

* 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있어 오버로드 중 상당수를 피할 수 있음

  ```kotlin
  fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
  ): String
  ```

* 이름 붙인 인자를 사용할 경우, 디폴트 파라미터 중 인자를 생략하고 지정하고 싶은 순서대로 이름을 붙여 사용 가능

  ```kotlin
  joinToString(collection, postfix = ".", prefix = "")
  ```

* 함수의 디폴트 파라미터 값은 함수를 호출하는 곳이 아닌 선언하는 곳에서 지정

* 자바에서는 해당 개념이 없기 때문에 코틀린 함수를 자바에서 호출해야 하는 경우 해당 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시

* 자바에서 `@JvmOverloads` 어노테이션을 함수에 추가하면 컴파일러가 자동으로 맨 마지막 파라미터로부터 하나씩 생략한 오버로딩 메소드를 추가해줌

### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

* 코틀린에서는 클래스를 적지 않고 함수를 소스파일의 최상위 수준으로 위치 시킬 수 있음
* 해당 함수들은 패키지의 멤버 함수이기 때문에 다른 패지키에서 사용시에는 임포트가 필수
* JVM에서는 최상위 함수가 존재할 시 새로운 클래스를 정의하고 그 안에 함수를 넣어 실행(만약 파일 이름이 join.kt 라면 `JoinKt` 라는 클래스가 자동으로 생성)
* 만약 클래스의 이름을 바꾸고 싶다면 `@JvmName` 어노테이션을 추가하고 속성에 이름을 명시
* 함수와 마찬가지로 프로퍼티 또한 최상위 수준에 위치할 수 있음
* 기본적으로 최상위 프로퍼티는 다른 프로퍼티와 마찬가지로 접근자(게터, 세터) 접근 메소드를 통해 자바 코드에 노출
* 상수의 경우 `const` 키워드(원시 타입과 String만)를 사용하면 자동으로 `public static final`로 컴파일

<br>

## 3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

* 기존 자바 API를 건들이지 않고 코틀린이 여러 편리한 함수를 제공하는 이유는 확장 함수에 있음
* 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만, 클래스 밖에 선언된 함수

```kotlin
//stringUtil.kt
package strings

	//수신 객체 타입            //수신 객체  //수신 객체
fun String.lastChar(): Char = this.get(this.length - 1)
```

* 확장 함수를 만들기 위해서는 확장할 클래스 이름을 작성하고 메소드 이름을 정의
* 클래스 이름을 **수신 객체 타입**(`String`)이라고 하고 확장 함수가 호출이 되는 값을 **수신 객체**(`this`)라고 부름
* 코틀린 뿐만아닌 그루비와 같은 다른 JVM 언어로 작성된 클래스도 확장 가능(자바에 정의 되어 있는 클래스만)
* 위의 예시에서 일반 메소드와 마찬가지로 확장 함수 본문에서도 `this`를 생략 가능
* 확장 함수 내부에서 수신 객체의 메소드나 프로퍼티를 바로 사용 가능
* 확장 함수 안에서는 클래스 내부에서 사용할 수 있는 private / protect 멤버를 사용 불가

### 3.3.1 임포트와 확장 함수

* 확장 함수를 사용하기 위해서는 임포트는 필수(만약 이가 없다면 함수의 이름들이 중복 발생)

* `as` 키워드를 사용하여 임포트한 클래스 혹은 함수를 다른 이름으로 부를 수 있음

  ```kotlin
  import strings.lastChar as last
  
  val l = "Kotlin".last()
  ```

* 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야하므로 이름을 변경하는 것이 확장 함수 이름의 충돌을 해결할 수 있는 유일한 방법

### 3.3.2 자바에서 확장 함수 호출 

* 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드, 따라서 부가 비용 발생 X

* 자바에서는 단지 정적 메소드를 호출하고 첫 번째 인자로 수신 객체만 넘기기만 하면 됨

  ```java
  char c = stringUtilKt.lastChar("Java");
  ```

### 3.3.3 확장 함수로 유틸리티 함수 정의

* 확장 함수는 단지 정적 메소드 호출에 대한 문법 설탕
* 클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 설정 가능

### 3.3.4 확장 함수는 오버라이드할 수 없다

* 확장 함수는 정적 메소드와 같은 특징을 가지므로 확장 함수를 하위 클래스에서 오버라이드 할 수 없음
* 확장 함수는 클래스의 일부가 아닌 클래스 밖에서 선언하기 때문에 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출 될 지 결정
* 이는 자바에서 호출 할 때 컴파일러가 정적 메소드로 변경한다는 사실을 안다면 쉽게 이해 가능
* 만약 멤버 함수와 확장 함수의 메소드 시그니처가 같다면 멤버 함수 우선 호출

### 3.3.5 확장 프로퍼티

* 확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가 가능
* 프로퍼티라고 불리우지만 상태를 저장할 적절한 방법이 없기에 실제로 확장 프로퍼티는 아무 상태도 가질 수 없음(기존 클래스의 인스턴스 객체에 필드를 추가할 방법 따위 없음)

```kotlin
val String.lastChar: Char
	get() = get(length - 1)
```

* 확장 함수와 일반적으로 같고 **수신 객체 클래스**가 추가 되었을 뿐
* 뒷받침하는 필드가 없기 때문에 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의

<br>

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

* `vararg` 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의
* 중위 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출
* 구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있음

### 3.4.1 자바 컬렉션 API 확장

* 코틀린에서 `List` 클래스의 `last`와 `max`는 확장 함수
* 다 알 필요는 없고 궁금할 때마다 찾아보고 IDE를 적극 활용

### 3.4.2 가변 인자 함수: 인자 개수가 달라질 수 있는 함수 정의

* 가변 길이 인자는 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값을 넣어주는 기능
* 코틀린 가변 길이 인자도 자바와 비슷(자바 : 타입 뒤 `...` | 코틀린 : 파라미터 앞 `vararg`)
* 자바에서는 배열을 그냥 넘기지만 코틀린에서는 명시적으로 풀어 전달, 이를 스프레드 연산자가 대신 해줌(배열 앞에 `*`를 붙히기만 하면 됨)

### 3.4.3 값의 쌍 다루기: 중위 호출과 구조 분해 선언

```kotlin
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

* 위 `to`는 키워드가 아닌 **중위 호출**이라는 특별한 방식으로 `to` 메소드를 호출한 것
* 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 이름을 작성(무조건 인자가 하나인 함수에서만 사용)
* 함수를 중위 호출을 허용하게 하려면 `infix` 변경자를 함수 선언 앞에 추가

```kotlin
val (number, name) = 1 to "one"
```

* 위와 같은 기능을 **구조 분해 선언**이라고 함
* 여러 곳에서 구조 분해 선언을 사용할 수 있음(루프)

<br>

## 3.5 문자열과 정규식 다루기

* 코틀린 문자열을 자바 문자열과 같으나 다양한 확장 함수를 제공

### 3.5.1 문자열 나누기

* 자바의 `split` 함수는 넘기는 인자 타입이 정규식, 따라서 `"."`을 넘기면 모든 문자를 나타내는 정규식으로 해석
* 코틀린에서는 여러가지 조합의 파라미터를 받는 `split` 확장 함수를 제공

### 3.5.2 정규식과 3중 따옴표로 묶은 문자열

* 3중 따옴표(`"""`) 문자열에서는 역슬래시(`\`)를 포함하여 어떤 문자도 이스케이프할 필요가 없음

### 3.5.3 여러 줄 3중 따옴표 문자열

* 3중 따옴표 문자열에는 줄 바꿈을 표현하는 아무 문자열이나 그냥 들어감  
  따라서 줄 바꿈이 들어있는 프로그램 텍스트를 쉽게 문자열로 만들 수 있음
* 3중 따옴표 문자열 안에 문자열 템플릿도 사용 가능
* 문자열 템플릿 안에 `$` 문자를 넣어야 한다면 `''`를 사용
* 이와 같이 기존 라이브러리를 새 언어에서 활용하는 패턴을 **라이브러리 알선** 패턴이라고 함

<br>

## 3.6 코드 다듬기: 로컬 함수와 확장

* 리팩토링시 긴 메소드를 부분부분 나누어 재활용을 할 수 있지만 오히려 가독성을 해칠 수 있음

* 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩 가능  
  즉, 함수 안에 또다른 함수를 만들어 사용 가능

  ```kotlin
  fun saveUser(user: User) {
    fun validate(user: User, value: String, fieldName: String) {
      ...
    }
    
    validate(user, user.name, "Name")
  }
  ```

* 로컬 함수의 경우 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용 가능

  ```kotlin
  fun saveUser(user: User) {
    fun validate(value: String, fieldName: String) {
      ...
    }
    
    validate(user.name, "Name")
  }
  ```

* 더 나아가 따로 확장 함수로 빼낼 수도 있음

  ```kotlin
  fun User.validateBeforeSave() {
    fun validate(value: String, fieldName: String) {
      ...
    }
    
    validate(name, "Name")
  }
  
  fun saveUser(user: User) {
    user.validateBeforeSave()
  }

* 로컬 함수가 편리할 때가 있지만 중첩된 함수의 깊이가 깊어지면 가독성을 해침  
  따라서 한 단계만 하는 것을 권장