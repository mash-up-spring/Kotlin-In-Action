# 1 코틀린이란 무엇이며, 왜 필요한가?
1장에서 다루는 내용
- 코틀린 기본 기능 데모
- 코틀린 언어의 주요 특성
- 코틀린을 활용한 안드로이드, 서버 개발
- 코틀린이 다른 언어보다 더 나은 점
- 코틀린으로 코드를 작성하고 실행하는 방법

---
코틀린은 자바 플랫폼에서 돌아가는 프로그래밍 언어다. 간결하고 실용적이며 자바와의 상호운용성을 중시한다.

## 1.1 코틀린 맛보기
```kotlin
data class Person(val name: String,
                  val age: Int? = null)

fun main(args: Array<String>) {
    val persons = listOf(Person("영희"),
                         Person("철수", age = 29))

    val oldest = persons.maxBy { it.age ?: 0 }
    println("나이가 가장 많은 사람 : $oldest")
}
```
- maxBy 함수에 전달한 람다식은 파라미터를 하나 받는다. it이라는 이름을 사용하면 람다 식의 유일한 인자를 사용할 수 있다.
- ?:는 엘비스 연산자라고 불리며 null인경우 0을 반환 하고 아닐 경우 age를 반환 한다.

<br>

## 1.2 코틀린의 주요 특성
<br>

### 1.2.1 대상 플랫폼 : 서버, 안드로이드 등 자바가 실행되는 모든 곳 
<br>

### 1.2.2 정적 타입 지정 언어
정적 타입 언어지만 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다. 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있다.<br>
```kotlin
var x = 1
```
위 처럼 선언 하면 코틀린은 이 변수의 타입이 Int임을 자동으로 알아낸다.

<br>

### 1.2.3 함수형 프로그래밍과 객체지향 프로그래밍
함수형 프로그래밍의 핵심 개념
- 일급 함수 : 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있다.
- 불변성 : 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.
- 부수 효과 없음 : 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.

아래와 같이 공통 로직을 함수로 뽑아낸 후 세부 사항을 인자로 전달 할 수 있다.
```kotlin
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```

<br>

함수형 프로그래밍의 두 번째 유익은 다중 스레드를 사용해도 안전하다는 사실이다. 불변 데이터 구조를 사용하고 순수 함수를 데이터 구조에 적용 한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다. 따라서 동기화를 적용하지 않아도 된다.<br>
마지막으로 함수형 프로그램은 테스트하기 쉽다. 준비 코드 없이 독립적으로 테스트할 수 있다.

<br> 

### 1.2.4 무료 오픈소스

<br>

## 1.3 코틀린 응용

<br>

### 1.3.1 코틀린 서버 프로그래밍
기존 자바코드와매끄럽게 상호운용할 수 있다는 점이 코틀린의 큰 장점이다. 코틀린은 새로운 컴포넌트를 작성하거나 기존 서비스 코드를 코틀린으로 이식해야 하는 경우에 모두 잘 들어맞는다. 자바 클래스를 코틀린으로 확장해도 아무 문제가 없으며, 코틀린 클래스 안의 메소드나 필드에 특정 애노테이션을 붙여야 하는 경우에도 아무 문제가 없다.

<br>

**Exposed 프레임워크의 예**
```kotlin
object CountryTable : IdTable() {
    val name = varchar("name", 250).uniqueIndex()
    val iso = varchar("iso", 2).uniqueIndex()
}

class Country(id: EntityID) : Entity(id) {
    var name: String by CountryTable.name
    var iso: String by CountryTable.iso
}

val russia = Country.find {
    CountryTable.iso.eq("ru")
}.first()
```

### 1.3.2 코틀린 안드로이드 프로그래밍
생략

<br>

## 1.4 코틀린의 철학

<br>

### 1.4.1 실용성
코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어다. 연구를 위한 언어가 아니다. 코틀린은 어느 특정 프로그래밍 스타일이나 패러다임을 사용할 것을 강제 하지 않는다. Intellij와의 통합도 굿.

<br>

### 1.4.2 간결성
코틀린을 만들면서 프로그래머가 작성하는 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다. 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 준비코드를 묵시적으로 제공 한다.

<br>

### 1.4.3 안전성
코틀린을 만들면서 자바보다 더 높은 수준의 안전성을 달성하되 전체 비용은 더 적게 지불하고 싶었다. 타입 안정성, 한걸음 더 나아가 실행 시점에 오류를 발생시키는 대신 컴파일 시점 검사를 통해 오류를 더 많이 방지해준다. 코틀린의 타입 시스템은 NULL이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다.<br>
또한 ClassCastException을 방지 해준다. 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다.
```kotlin
if (value is String)
    println(value.toUpperCase())
```

<br>

### 1.4.4 상호운용성
기존 자바 라이브러리를 그대로 사용할 수 있다. 자바 메소드를 호출하거나 자바 클래스를 상속하거나 인터페이스를 구현 하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.<br>
코틀린은 자체 컬렉션 라이브러리를 제공하지 않는다. 자바 표준 라이브러리 클래스에 의존한다. 다만 코틀린에서 더 쉽게 활용할 수 있게 몇 가지 기능을 더할 뿐이다.