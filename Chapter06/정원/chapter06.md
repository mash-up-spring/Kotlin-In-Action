# 코틀린 타입 시스템

6장에서 다루는 내용
- 널이 될 수 있는 타입과 널을 처리하는 구문의 문법
- 코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계
- 코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계

## 널 가능성
NPE를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.<br>
널을 받기 위해서는 타입 이름 뒤에 물음표(?)를 명시해야 한다. String?, Int? 등 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼디에 null 참조를 저장할 수 있다는 뜻이다.<br>
?. 연산자를 붙이면 안전한 연산을 수행 할 수 있다. 예를 들어 s?.toUpperCase()는 if (s != null) s.toUpperCase() else null 과 같다.

### 엘비스 연산자
```kotlin
fun foo(s: String?) {
    val t: String = s ?: "" // s가 널이면 결과는 빈 문자열 이다.
}
```

### 안전한 캐스트 as?

### 널 아님 단언: !!

### let 함수
```kotlin
// let을 사용해 null이 아닌 인자로 함수 호출하기
var email : String? = "y•le@example .c•m'' 
email?.let { sendEmailTo(it) }
```

### 나중에 초기화할 프로퍼티
- lateinit 붙이기

### 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다.

### 타입 파라미터의 널 가능성
코틀린에서는 타입 파라미터는 기본적으로 널이 될 수 있다. 물음표가 없더라도 T가 널이 될 수 있는 타입이다.

### 널 가능성과 자바
자바는 Nullable을 지원하지 않는데 어떻게 상호 운용성? 자바의 @Nullable 어노테이션을 본다.
어노테이션이 없는 경우 플랫폼 타입이 되는데, Nullable로 처리해도 되고 안해도 된다.

## 코틀린의 원시 타입

### 원시타입: Int, Boolean 등
코틀린은 원시 타입과 래퍼 타이븡ㄹ 구분하지 않으므로 항상 같은 타입을 사용한다. 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다. <br>
널이 가능한 원시타입 Int?, Boolean? 등도 있다.

### 숫자 변환
코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.
```kotlin
val i = 1
val l: Long = i //컴파일 오류 발생

// 변환 메소드를 직접 호출해야 한다.
val i = 1
val l: Long = i.toLong()
```

### Any, Any?: 최상위 타입
코틀린에서는 Any가 Int등 원시타입을 포함한 모든 타입의 조상 타입이다.

### Unit 타입: 코틀린의 void

### Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다.
테스트 라이브러리의 fail등 특별한 메세지의 반환 타입

## 컬렉션과 배열

### Nullable과  컬렉션
List<Int?> 처럼 사용 가능. <br>
filterNotNull로 널이 될 수 있는 값으로 이뤄진 컬렉션에 대해 사용하기

### 읽기 전용과 변경 가능한 컬렉션
코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에서는 컬렉션안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다. <br>
컬렉션을 수정 하려면 MutableCollection을 사용하라.